<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <title>Donkey Dystopia 320</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body {
      margin: 0;
      display: flex;
      width: 100vw;
      height: 100vh;
      align-items: center;
      justify-content: center;
      background: #000;
    }

    main,
    canvas {
      width: min(100vw, 100vh * (320 / 200));
      height: min(100vh, 100vw / (320 / 200));
      display: block;
    }

    canvas {
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: #000;
    }
  </style>
</head>
<body>
  <main>
    <canvas id="screen" width="320" height="200" aria-label="Retro Schauplatz"></canvas>
  </main>

  <script type="module">
    import { RetroPalette, RetroBuffer, Sprite, blitSprite } from './retroBlitter.js';

    const WIDTH = 320;
    const HEIGHT = 200;
    const GROUND_HEIGHT = 8;
    const MOVE_SPEED = 78;
    const GRAVITY = 280;
    const JUMP_FORCE = 180;
    const TEXT_WRAP = 26;

    const canvas = document.getElementById('screen');
    const ctx = canvas.getContext('2d');

    const { palette, colors } = createPalette();
    const retroPalette = new RetroPalette(palette);
    const buffer = new RetroBuffer(WIDTH, HEIGHT, retroPalette);

    const wizardSprites = createWizardSprites(colors);
    const donkeySprites = createDonkeySprites(colors);
    const cloudSprites = createCloudSprites(colors);
    const textRenderer = createTextRenderer(colors);

    const wizard = {
      sprites: wizardSprites,
      x: 48,
      y: groundLineFor(wizardSprites.right),
      vx: 0,
      vy: 0,
      facing: 1,
      onGround: true,
    };

    const donkeyBaseY = groundLineFor(donkeySprites.right);
    const donkey = {
      sprites: donkeySprites,
      x: wizard.x - 32,
      y: donkeyBaseY,
      facing: 1,
    };

    const clouds = createClouds(cloudSprites);

    const controls = new Set(['w', 'a', 's', 'd']);
    const heldKeys = new Set();
    const pressedKeys = new Set();

    const speechState = createSpeechState();
    let speechQueue = Promise.resolve();

    let cameraX = 0;
    let lastTime = performance.now();

    window.addEventListener('keydown', handleKeyDown);
    window.addEventListener('keyup', handleKeyUp);
    window.addEventListener('blur', () => {
      heldKeys.clear();
      pressedKeys.clear();
    });

    requestAnimationFrame(loop);
    main();

    async function main() {
      await say(
        () => wizard.x + wizard.sprites.right.width / 2,
        () => wizard.y + 6,
        'Hallo, ich bin Harald Töpfer, der Zauberlehrling'
      );
    }

    function handleKeyDown(event) {
      const key = event.key.toLowerCase();
      if (!controls.has(key)) return;
      if (!heldKeys.has(key)) {
        pressedKeys.add(key);
      }
      heldKeys.add(key);
      event.preventDefault();
    }

    function handleKeyUp(event) {
      const key = event.key.toLowerCase();
      if (!controls.has(key)) return;
      heldKeys.delete(key);
      pressedKeys.delete(key);
      event.preventDefault();
    }

    function loop(time) {
      const delta = Math.min(0.05, (time - lastTime) / 1000);
      lastTime = time;

      updateWizard(delta);
      updateDonkey(delta, time);

      const targetCamera = Math.max(0, wizard.x + wizard.sprites.right.width / 2 - WIDTH / 2);
      cameraX += (targetCamera - cameraX) * Math.min(1, delta * 6);

      updateClouds(delta, time);
      updateSpeech(time);
      drawScene(time);

      const frame = buffer.toImageData(ctx);
      ctx.putImageData(frame, 0, 0);

      pressedKeys.clear();
      requestAnimationFrame(loop);
    }

    function updateWizard(delta) {
      const left = heldKeys.has('a');
      const right = heldKeys.has('d');
      const crouch = heldKeys.has('s');
      const jumpPressed = pressedKeys.has('w');

      let desired = 0;
      if (left) desired -= MOVE_SPEED;
      if (right) desired += MOVE_SPEED;

      wizard.vx = desired;
      if (desired !== 0) {
        wizard.facing = desired > 0 ? 1 : -1;
      }

      if (jumpPressed && wizard.onGround) {
        wizard.vy = -JUMP_FORCE;
        wizard.onGround = false;
      }

      const gravityForce = GRAVITY * delta;
      wizard.vy += gravityForce;
      if (!heldKeys.has('w') && wizard.vy < 0) {
        wizard.vy += GRAVITY * 0.35 * delta;
      }
      if (crouch && wizard.vy > 0) {
        wizard.vy += GRAVITY * 0.5 * delta;
      }

      wizard.x += wizard.vx * delta;
      wizard.y += wizard.vy * delta;

      if (wizard.x < 0) wizard.x = 0;

      const groundLine = groundLineFor(wizard.sprites.right);
      if (wizard.y > groundLine) {
        wizard.y = groundLine;
        wizard.vy = 0;
        wizard.onGround = true;
      } else {
        wizard.onGround = false;
      }

      if (wizard.y < 24) {
        wizard.y = 24;
        if (wizard.vy < 0) wizard.vy = 0;
      }
    }

    function updateDonkey(delta, time) {
      const followOffset = 28;
      const desired = wizard.x - followOffset;
      const gap = desired - donkey.x;
      const maxSpeed = 35 + Math.min(110, Math.abs(gap) * 1.5);
      donkey.x += clamp(gap, -maxSpeed * delta, maxSpeed * delta);

      if (Math.abs(gap) > 0.5) {
        donkey.facing = gap > 0 ? 1 : -1;
      }

      const maxLead = wizard.x + 36;
      if (donkey.x > maxLead) {
        donkey.x = maxLead;
      }

      donkey.y = donkeyBaseY + Math.sin(time * 0.003 + donkey.x * 0.02) * 1.5;
    }

    function updateClouds(delta, time) {
      const span = WIDTH + 160;
      for (const cloud of clouds) {
        cloud.x += cloud.speed * delta;
        const parallaxX = cloud.x - cameraX * 0.4;
        if (parallaxX < -cloud.sprite.width - 40) {
          cloud.x += span;
        } else if (parallaxX > span) {
          cloud.x -= span;
        }
        cloud.y = cloud.baseY + Math.sin(time * 0.0006 + cloud.phase) * 4;
      }
    }

    function updateSpeech(time) {
      if (!speechState.active) return;

      if (speechState.visible < speechState.totalChars) {
        while (time >= speechState.nextCharTime && speechState.visible < speechState.totalChars) {
          speechState.visible++;
          speechState.nextCharTime += speechState.charDelay;
        }
        if (speechState.visible >= speechState.totalChars && speechState.holdUntil === Infinity) {
          speechState.holdUntil = time + speechState.holdDuration;
        }
      } else if (time >= speechState.holdUntil) {
        speechState.active = false;
        speechState.sequence = [];
        speechState.lines = [];
        speechState.anchor = null;
        const resolve = speechState.resolve;
        speechState.resolve = null;
        if (resolve) resolve();
      }
    }

    function drawScene(time) {
      drawSky();
      drawCloudLayer();
      drawHills(time);
      drawTerrain(time);
      drawCharacters();
      drawSpeechBubble();
    }

    function drawSky() {
      const pixels = buffer.pixels;
      for (let y = 0; y < HEIGHT; y++) {
        let color = colors.skyBottom;
        if (y < 70) {
          color = colors.skyTop;
        } else if (y < 120) {
          color = colors.skyMid;
        }
        const rowStart = y * WIDTH;
        pixels.fill(color, rowStart, rowStart + WIDTH);
      }
    }

    function drawCloudLayer() {
      for (const cloud of clouds) {
        const screenX = Math.round(cloud.x - cameraX * 0.4);
        const screenY = Math.round(cloud.y);
        blitSprite(buffer, cloud.sprite, screenX, screenY, { transparent: colors.transparent });
      }
    }

    function drawHills(time) {
      const pixels = buffer.pixels;
      const horizon = HEIGHT - GROUND_HEIGHT - 1;
      const parallax = cameraX * 0.6;
      for (let x = 0; x < WIDTH; x++) {
        const worldX = parallax + x;
        const height = 18 + Math.sin(worldX * 0.02) * 8 + Math.sin(worldX * 0.045 + time * 0.0004) * 6;
        const hillTop = Math.max(36, Math.floor(horizon - height));
        for (let y = hillTop; y <= horizon; y++) {
          const idx = y * WIDTH + x;
          const depth = horizon - y;
          pixels[idx] = depth < 4 ? colors.hillLight : colors.hillShadow;
        }
      }
    }

    function drawTerrain(time) {
      const pixels = buffer.pixels;
      const grassStart = HEIGHT - GROUND_HEIGHT;
      const worldOffset = Math.floor(cameraX);
      for (let y = grassStart; y < HEIGHT; y++) {
        const rowStart = y * WIDTH;
        const layer = HEIGHT - y;
        for (let x = 0; x < WIDTH; x++) {
          const idx = rowStart + x;
          const worldX = worldOffset + x;
          if (layer >= 6) {
            const sway = Math.sin(time * 0.004 + worldX * 0.05);
            pixels[idx] = sway > 0 ? colors.grassBright : colors.grassDark;
          } else if (layer >= 4) {
            pixels[idx] = colors.grassShadow;
          } else {
            const pattern = ((worldX + y) & 1) === 0;
            pixels[idx] = pattern ? colors.dirt : colors.dirtDeep;
          }
        }
      }
    }

    function drawCharacters() {
      const wizardSprite = wizard.facing >= 0 ? wizard.sprites.right : wizard.sprites.left;
      const wizardX = Math.round(wizard.x - cameraX);
      const wizardY = Math.round(wizard.y);
      blitSprite(buffer, wizardSprite, wizardX, wizardY, { transparent: colors.transparent });

      const donkeySprite = donkey.facing >= 0 ? donkey.sprites.right : donkey.sprites.left;
      const donkeyX = Math.round(donkey.x - cameraX);
      const donkeyY = Math.round(donkey.y);
      blitSprite(buffer, donkeySprite, donkeyX, donkeyY, { transparent: colors.transparent });
    }

    function drawSpeechBubble() {
      if (!speechState.active || speechState.totalChars === 0 && speechState.visible === 0 && speechState.holdUntil === Infinity) {
        return;
      }

      const anchorXWorld = resolveAnchor(speechState.anchor?.x, wizard.x + wizard.sprites.right.width / 2);
      const anchorYWorld = resolveAnchor(speechState.anchor?.y, wizard.y);

      const anchorX = Math.round(anchorXWorld - cameraX);
      const anchorY = Math.round(anchorYWorld);

      const width = speechState.width;
      const height = speechState.height;
      const bubbleLeftLimit = 2;
      const bubbleRightLimit = WIDTH - width - 2;
      let bubbleX = clamp(anchorX - Math.floor(width / 2), bubbleLeftLimit, bubbleRightLimit);
      const bubbleBottom = anchorY - speechState.tipHeight;
      const bubbleY = bubbleBottom - height;
      const bubbleRight = bubbleX + width;

      fillRect(buffer, bubbleX, bubbleY, width, height, colors.bubbleFill);
      drawBubbleTip(bubbleX, bubbleBottom, bubbleRight, anchorX, anchorY, speechState.tipBaseHalf, colors.bubbleFill, colors.bubbleBorder);
      strokeRect(buffer, bubbleX, bubbleY, width, height, colors.bubbleBorder);

      const textStartX = bubbleX + speechState.paddingX;
      const textStartY = bubbleY + speechState.paddingY;
      const charAdvance = textRenderer.width + textRenderer.spacing;
      const lineAdvance = textRenderer.height + textRenderer.lineSpacing;

      for (let i = 0; i < speechState.visible && i < speechState.sequence.length; i++) {
        const node = speechState.sequence[i];
        if (!node) continue;
        const glyph = textRenderer.glyphs[node.char];
        if (!glyph) continue;
        const gx = textStartX + node.column * charAdvance;
        const gy = textStartY + node.line * lineAdvance;
        blitSprite(buffer, glyph, gx, gy, { transparent: colors.transparent });
      }
    }

    function resolveAnchor(source, fallback) {
      if (typeof source === 'function') return source();
      if (typeof source === 'number') return source;
      return fallback;
    }

    async function say(x, y, text) {
      speechQueue = speechQueue.then(() => startSpeech(x, y, String(text ?? '')));
      return speechQueue;
    }

    function startSpeech(x, y, text) {
      return new Promise(resolve => {
        const now = performance.now();
        const lines = wrapText(text, TEXT_WRAP);
        const sequence = [];
        let maxLineLength = 0;

        for (let lineIndex = 0; lineIndex < lines.length; lineIndex++) {
          const line = lines[lineIndex];
          maxLineLength = Math.max(maxLineLength, line.length);
          for (let column = 0; column < line.length; column++) {
            const rawChar = line[column];
            const glyphChar = mapGlyphChar(rawChar);
            sequence.push({ line: lineIndex, column, char: glyphChar });
          }
        }

        const charWidth = textRenderer.width;
        const charSpacing = textRenderer.spacing;
        const lineSpacing = textRenderer.lineSpacing;
        const charAdvance = charWidth + charSpacing;
        const lineAdvance = textRenderer.height + lineSpacing;

        const textWidth = maxLineLength > 0 ? maxLineLength * charAdvance - charSpacing : 0;
        const textHeight = lines.length > 0 ? lines.length * lineAdvance - lineSpacing : 0;

        speechState.active = true;
        speechState.anchor = {
          x: typeof x === 'function' ? x : () => x,
          y: typeof y === 'function' ? y : () => y,
        };
        speechState.width = Math.max(12, textWidth + speechState.paddingX * 2);
        speechState.height = Math.max(10, textHeight + speechState.paddingY * 2);
        speechState.lines = lines;
        speechState.sequence = sequence;
        speechState.totalChars = sequence.length;
        speechState.visible = 0;
        speechState.nextCharTime = now;
        speechState.holdUntil = sequence.length === 0 ? now + speechState.holdDuration : Infinity;
        speechState.resolve = resolve;
      });
    }

    function wrapText(text, limit) {
      const words = text.split(/\s+/).filter(Boolean);
      const lines = [];
      let current = '';

      if (words.length === 0) {
        return [''];
      }

      for (const word of words) {
        const next = current.length === 0 ? word : `${current} ${word}`;
        if (next.length <= limit) {
          current = next;
          continue;
        }
        if (current.length > 0) {
          lines.push(current);
          current = word;
        } else {
          let remaining = word;
          while (remaining.length > limit) {
            lines.push(remaining.slice(0, limit));
            remaining = remaining.slice(limit);
          }
          current = remaining;
        }
      }

      if (current.length > 0) {
        lines.push(current);
      }

      return lines.length > 0 ? lines : [''];
    }

    function mapGlyphChar(char) {
      if (char === ' ') return ' ';
      if (char === ',') return ',';
      if (char === '.') return '.';
      if (char === '-') return '-';
      const upper = char.toUpperCase();
      if (textRenderer.glyphs[upper]) return upper;
      return ' ';
    }

    function drawBubbleTip(left, bubbleBottom, right, anchorX, anchorY, baseHalf, fillColor, borderColor) {
      const tipHeight = Math.max(1, Math.min(24, anchorY - bubbleBottom));
      const clampedAnchorX = clamp(anchorX, left + 2, right - 3);
      for (let i = 0; i < tipHeight; i++) {
        const rowY = bubbleBottom + i;
        if (rowY < 0 || rowY >= HEIGHT) continue;
        const t = tipHeight > 1 ? i / (tipHeight - 1) : 1;
        const half = Math.max(0, Math.round(baseHalf * (1 - t)));
        let start = clamp(clampedAnchorX - half, left, right - 1);
        let end = clamp(clampedAnchorX + half, left, right - 1);
        for (let x = start; x <= end; x++) {
          buffer.pixels[rowY * WIDTH + x] = fillColor;
        }
        if (rowY > bubbleBottom) {
          if (start >= left && start < right) {
            buffer.pixels[rowY * WIDTH + start] = borderColor;
          }
          if (end >= left && end < right) {
            buffer.pixels[rowY * WIDTH + end] = borderColor;
          }
        }
      }
      const tipY = clamp(anchorY, 0, HEIGHT - 1);
      const tipX = clamp(anchorX, 0, WIDTH - 1);
      buffer.pixels[tipY * WIDTH + tipX] = borderColor;
    }

    function createSpeechState() {
      return {
        active: false,
        anchor: null,
        width: 0,
        height: 0,
        paddingX: 4,
        paddingY: 4,
        tipHeight: 10,
        tipBaseHalf: 5,
        charDelay: 60,
        holdDuration: 1400,
        lines: [],
        sequence: [],
        totalChars: 0,
        visible: 0,
        nextCharTime: 0,
        holdUntil: Infinity,
        resolve: null,
      };
    }

    function fillRect(bufferRef, x, y, width, height, color) {
      if (width <= 0 || height <= 0) return;
      const startX = Math.max(0, Math.min(bufferRef.width, x));
      const endX = Math.max(0, Math.min(bufferRef.width, x + width));
      const startY = Math.max(0, Math.min(bufferRef.height, y));
      const endY = Math.max(0, Math.min(bufferRef.height, y + height));
      for (let yy = startY; yy < endY; yy++) {
        const offset = yy * bufferRef.width;
        bufferRef.pixels.fill(color, offset + startX, offset + endX);
      }
    }

    function strokeRect(bufferRef, x, y, width, height, color) {
      if (width <= 0 || height <= 0) return;
      const x1 = x;
      const x2 = x + width - 1;
      const y1 = y;
      const y2 = y + height - 1;
      drawHorizontalLine(bufferRef, x1, x2, y1, color);
      drawHorizontalLine(bufferRef, x1, x2, y2, color);
      drawVerticalLine(bufferRef, x1, y1, y2, color);
      drawVerticalLine(bufferRef, x2, y1, y2, color);
    }

    function drawHorizontalLine(bufferRef, x1, x2, y, color) {
      if (y < 0 || y >= bufferRef.height) return;
      const start = Math.max(0, Math.min(x1, x2));
      const end = Math.min(bufferRef.width - 1, Math.max(x1, x2));
      const offset = y * bufferRef.width;
      for (let x = start; x <= end; x++) {
        bufferRef.pixels[offset + x] = color;
      }
    }

    function drawVerticalLine(bufferRef, x, y1, y2, color) {
      if (x < 0 || x >= bufferRef.width) return;
      const start = Math.max(0, Math.min(y1, y2));
      const end = Math.min(bufferRef.height - 1, Math.max(y1, y2));
      for (let y = start; y <= end; y++) {
        bufferRef.pixels[y * bufferRef.width + x] = color;
      }
    }

    function createWizardSprites(c) {
      const art = [
        '.........66.........',
        '........4664........',
        '........4664........',
        '........4664........',
        '.......466666.......',
        '......46686864......',
        '......46888864......',
        '......46818864......',
        '......46898864......',
        '.......468864.......',
        '........4664........',
        '........4444........',
        '.......333333.......',
        '......32222223......',
        '.....3225555223.....',
        '....322555555223....',
        '....325555555523....',
        '....325555555523....',
        '.....3257775523.....',
        '......22555522......',
        '......22555522......',
        '.......222222.......',
        '.......22..22.......',
        '......22....22......',
      ];
      const legend = {
        '.': c.transparent,
        '6': c.wizardHead,
        '4': c.wizardHeadHighlight,
        '8': c.wizardHeadGlow,
        '1': c.wizardEyeWhite,
        '9': c.wizardEyeDark,
        '3': c.wizardRobeShadow,
        '2': c.wizardRobe,
        '5': c.wizardRobeHighlight,
        '7': c.wizardBelt,
      };
      const right = spriteFromStrings(art, legend);
      return { right, left: mirrorSprite(right) };
    }

    function createDonkeySprites(c) {
      const art = [
        '............33........',
        '...........3663.......',
        '..........366663......',
        '.........33666663.....',
        '........3366666663....',
        '.......336666666663...',
        '......3366655556663...',
        '.....336665555556663..',
        '....3366655555555663..',
        '....3666555555555663..',
        '...36665555555555663..',
        '...36665555555555663..',
        '...3666557775555663...',
        '....366557778855663...',
        '....33366778899533....',
        '...33..333333..33.....',
        '...3...33..33...3.....',
        '.......3....3.........',
        '......33....33........',
      ];
      const legend = {
        '.': c.transparent,
        '3': c.donkeyShadow,
        '6': c.donkeyFur,
        '5': c.donkeyHighlight,
        '7': c.donkeyMuzzle,
        '8': c.donkeyEyeWhite,
        '9': c.donkeyEye,
      };
      const right = spriteFromStrings(art, legend);
      return { right, left: mirrorSprite(right) };
    }

    function createCloudSprites(c) {
      const sizes = [
        { width: 46, height: 16 },
        { width: 38, height: 14 },
        { width: 52, height: 18 },
      ];
      return sizes.map(size => generateCloudSprite(size.width, size.height, c));
    }

    function createClouds(cloudSprites) {
      const list = [];
      for (let i = 0; i < 6; i++) {
        const sprite = cloudSprites[i % cloudSprites.length];
        list.push({
          sprite,
          x: i * 72 + Math.random() * 40,
          baseY: 28 + (i % 3) * 18,
          y: 0,
          speed: 6 + Math.random() * 10,
          phase: Math.random() * Math.PI * 2,
        });
      }
      return list;
    }

    function generateCloudSprite(width, height, c) {
      const pixels = new Uint8Array(width * height);
      const centerX = (width - 1) / 2;
      const centerY = (height - 1) / 2;
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const nx = (x - centerX) / (width * 0.45);
          const ny = (y - centerY) / (height * 0.55);
          const dist = nx * nx + ny * ny;
          const idx = y * width + x;
          if (dist <= 1) {
            let shade = c.cloudLight;
            if (ny < -0.2) {
              shade = c.cloudHighlight;
            } else if (ny > 0.25) {
              shade = c.cloudShade;
            }
            pixels[idx] = shade;
          } else {
            pixels[idx] = c.transparent;
          }
        }
      }
      return new Sprite(width, height, pixels);
    }

    function spriteFromStrings(rows, legend) {
      const height = rows.length;
      const width = rows[0].length;
      const pixels = new Uint8Array(width * height);
      for (let y = 0; y < height; y++) {
        const row = rows[y];
        for (let x = 0; x < width; x++) {
          const key = row[x];
          const color = legend[key];
          if (color === undefined) {
            throw new Error(`Sprite legend missing key "${key}"`);
          }
          pixels[y * width + x] = color;
        }
      }
      return new Sprite(width, height, pixels);
    }

    function mirrorSprite(sprite) {
      const mirrored = new Uint8Array(sprite.width * sprite.height);
      for (let y = 0; y < sprite.height; y++) {
        const rowStart = y * sprite.width;
        for (let x = 0; x < sprite.width; x++) {
          mirrored[rowStart + x] = sprite.pixels[rowStart + (sprite.width - 1 - x)];
        }
      }
      return new Sprite(sprite.width, sprite.height, mirrored);
    }

    function groundLineFor(sprite) {
      return HEIGHT - GROUND_HEIGHT - sprite.height;
    }

    function clamp(value, min, max) {
      return Math.min(Math.max(value, min), max);
    }

    function createTextRenderer(c) {
      const glyphWidth = 5;
      const glyphHeight = 7;
      const spacing = 1;
      const lineSpacing = 2;
      const glyphs = {};
      const blank = new Sprite(glyphWidth, glyphHeight, new Uint8Array(glyphWidth * glyphHeight));
      glyphs[' '] = blank;

      const baseLegend = {
        '.': c.transparent,
        '#': c.textPrimary,
      };

      const patterns = getGlyphPatterns();
      for (const [char, rows] of Object.entries(patterns)) {
        glyphs[char] = spriteFromStrings(rows, baseLegend);
      }
      glyphs['.'] = spriteFromStrings([
        '.....',
        '.....',
        '.....',
        '.....',
        '.....',
        '..##.',
        '..##.',
      ], baseLegend);
      glyphs[','] = spriteFromStrings([
        '.....',
        '.....',
        '.....',
        '.....',
        '..##.',
        '..#..',
        '.#...',
      ], baseLegend);
      glyphs['-'] = spriteFromStrings([
        '.....',
        '.....',
        '.....',
        '#####',
        '.....',
        '.....',
        '.....',
      ], baseLegend);

      return { glyphs, width: glyphWidth, height: glyphHeight, spacing, lineSpacing };
    }

    function getGlyphPatterns() {
      return {
        'A': [
          '.###.',
          '#...#',
          '#...#',
          '#####',
          '#...#',
          '#...#',
          '#...#',
        ],
        'B': [
          '####.',
          '#...#',
          '#...#',
          '####.',
          '#...#',
          '#...#',
          '####.',
        ],
        'C': [
          '.###.',
          '#...#',
          '#....',
          '#....',
          '#....',
          '#...#',
          '.###.',
        ],
        'D': [
          '####.',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '####.',
        ],
        'E': [
          '#####',
          '#....',
          '#....',
          '####.',
          '#....',
          '#....',
          '#####',
        ],
        'F': [
          '#####',
          '#....',
          '#....',
          '####.',
          '#....',
          '#....',
          '#....',
        ],
        'G': [
          '.###.',
          '#...#',
          '#....',
          '#.###',
          '#...#',
          '#...#',
          '.###.',
        ],
        'H': [
          '#...#',
          '#...#',
          '#...#',
          '#####',
          '#...#',
          '#...#',
          '#...#',
        ],
        'I': [
          '#####',
          '..#..',
          '..#..',
          '..#..',
          '..#..',
          '..#..',
          '#####',
        ],
        'J': [
          '#####',
          '...#.',
          '...#.',
          '...#.',
          '#..#.',
          '#..#.',
          '.##..',
        ],
        'K': [
          '#...#',
          '#..#.',
          '#.#..',
          '##...',
          '#.#..',
          '#..#.',
          '#...#',
        ],
        'L': [
          '#....',
          '#....',
          '#....',
          '#....',
          '#....',
          '#....',
          '#####',
        ],
        'M': [
          '#...#',
          '##.##',
          '#.#.#',
          '#.#.#',
          '#.#.#',
          '#...#',
          '#...#',
        ],
        'N': [
          '#...#',
          '##..#',
          '#.#.#',
          '#..##',
          '#...#',
          '#...#',
          '#...#',
        ],
        'O': [
          '.###.',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '.###.',
        ],
        'P': [
          '####.',
          '#...#',
          '#...#',
          '####.',
          '#....',
          '#....',
          '#....',
        ],
        'Q': [
          '.###.',
          '#...#',
          '#...#',
          '#...#',
          '#.#.#',
          '#..#.',
          '.##.#',
        ],
        'R': [
          '####.',
          '#...#',
          '#...#',
          '####.',
          '#.#..',
          '#..#.',
          '#...#',
        ],
        'S': [
          '.####',
          '#....',
          '#....',
          '.###.',
          '....#',
          '....#',
          '####.',
        ],
        'T': [
          '#####',
          '..#..',
          '..#..',
          '..#..',
          '..#..',
          '..#..',
          '..#..',
        ],
        'U': [
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '.###.',
        ],
        'V': [
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '.#.#.',
          '..#..',
        ],
        'W': [
          '#...#',
          '#...#',
          '#...#',
          '#.#.#',
          '#.#.#',
          '##.##',
          '#...#',
        ],
        'X': [
          '#...#',
          '#...#',
          '.#.#.',
          '..#..',
          '.#.#.',
          '#...#',
          '#...#',
        ],
        'Y': [
          '#...#',
          '#...#',
          '.#.#.',
          '..#..',
          '..#..',
          '..#..',
          '..#..',
        ],
        'Z': [
          '#####',
          '....#',
          '...#.',
          '..#..',
          '.#...',
          '#....',
          '#####',
        ],
        'Ö': [
          '.#.#.',
          '.###.',
          '#...#',
          '#...#',
          '#...#',
          '#...#',
          '.###.',
        ],
      };
    }

    function createPalette() {
      const palette = [[0, 0, 0, 0]];
      const colorNames = {
        transparent: 0,
      };

      const baseColors = {
        black: [0, 0, 0, 255],
        skyTop: [18, 42, 92, 255],
        skyMid: [32, 68, 128, 255],
        skyBottom: [70, 104, 150, 255],
        cloudHighlight: [236, 244, 255, 255],
        cloudLight: [208, 226, 244, 255],
        cloudShade: [168, 192, 220, 255],
        hillLight: [58, 84, 118, 255],
        hillShadow: [40, 64, 100, 255],
        grassBright: [52, 170, 96, 255],
        grassDark: [34, 136, 76, 255],
        grassShadow: [20, 92, 52, 255],
        dirt: [104, 72, 48, 255],
        dirtDeep: [78, 54, 36, 255],
        wizardHead: [68, 132, 255, 255],
        wizardHeadHighlight: [124, 176, 255, 255],
        wizardHeadGlow: [44, 96, 202, 255],
        wizardEyeWhite: [248, 248, 255, 255],
        wizardEyeDark: [38, 46, 88, 255],
        wizardRobe: [96, 56, 142, 255],
        wizardRobeShadow: [62, 32, 104, 255],
        wizardRobeHighlight: [156, 100, 186, 255],
        wizardBelt: [196, 164, 92, 255],
        donkeyShadow: [54, 42, 36, 255],
        donkeyFur: [158, 129, 103, 255],
        donkeyHighlight: [210, 170, 130, 255],
        donkeyMuzzle: [196, 150, 110, 255],
        donkeyEyeWhite: [250, 247, 235, 255],
        donkeyEye: [38, 60, 92, 255],
        textPrimary: [245, 244, 254, 255],
        bubbleFill: [22, 28, 52, 240],
        bubbleBorder: [118, 200, 255, 255],
      };

      for (const [name, rgba] of Object.entries(baseColors)) {
        colorNames[name] = palette.length;
        palette.push(rgba);
      }

      while (palette.length < 256) {
        const i = palette.length;
        const r = (i * 47) % 256;
        const g = (i * 67) % 256;
        const b = (i * 13) % 256;
        palette.push([r, g, b, 255]);
      }

      return { palette, colors: colorNames };
    }
  </script>
</body>
</html>
